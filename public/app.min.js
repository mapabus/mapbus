class BusMapApp {
  constructor(config) {
    this.map = L.map('map').setView(config.mapCenter, config.mapZoom);
    this.markersLayer = L.layerGroup().addTo(this.map);
    this.colors = config.colors;
    this.directionColorMap = {};
    this.allMarkers = {};
    this.stationsMap = {};
    this.routeNamesMap = {};
    this.refreshInterval = config.refreshInterval;
    
    // NOVI - Shapes podaci i istorija vozila
    this.shapesData = {};
    this.shapesGradskeData = {};
    this.vehicleHistory = {};
    this.routeMappingData = {};
    
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(this.map);
    
    this.init();
  }

  async init() {
    await this.loadStations();
    await this.loadRouteNames();
    await this.loadShapes();
    this.loadVehicles();
    this.startAutoRefresh();
  }

  // ========== SHAPES UTILITY FUNKCIJE - ISPRAVLJENA LOGIKA ==========

  parseShapesFile(text) {
    const lines = text.split('\n');
    const shapes = {};
    
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      
      const parts = line.split(',');
      if (parts.length < 4) continue;
      
      const shapeId = parts[0].trim();
      const lat = parseFloat(parts[1]);
      const lon = parseFloat(parts[2]);
      const sequence = parseInt(parts[3]);
      
      if (isNaN(lat) || isNaN(lon) || isNaN(sequence)) continue;
      
      if (!shapes[shapeId]) {
        shapes[shapeId] = [];
      }
      
      shapes[shapeId].push({ lat, lon, sequence });
    }
    
    Object.keys(shapes).forEach(shapeId => {
      shapes[shapeId].sort((a, b) => a.sequence - b.sequence);
    });
    
    return shapes;
  }

  async loadShapes() {
    try {
      const shapesResponse = await fetch('/api/shapes.txt');
      const shapesText = await shapesResponse.text();
      this.shapesData = this.parseShapesFile(shapesText);
      
      const shapesGradskeResponse = await fetch('/api/shapes_gradske.txt');
      const shapesGradskeText = await shapesGradskeResponse.text();
      this.shapesGradskeData = this.parseShapesFile(shapesGradskeText);
      
      console.log('✅ Shapes učitani:', Object.keys(this.shapesData).length, '+', Object.keys(this.shapesGradskeData).length);
    } catch (error) {
      console.error('❌ Greška pri učitavanju shapes:', error);
    }
  }

  haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon / 2) * Math.sin(dLon / 2);
    
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  findNearestPointOnShape(lat, lon, shape) {
    let minDistance = Infinity;
    let nearestIndex = 0;
    
    for (let i = 0; i < shape.length; i++) {
      const distance = this.haversineDistance(lat, lon, shape[i].lat, shape[i].lon);
      if (distance < minDistance) {
        minDistance = distance;
        nearestIndex = i;
      }
    }
    
    return nearestIndex;
  }

  // ISPRAVLJENA FUNKCIJA - Računa distancu duž CELE trase između dve tačke
  calculateRouteDistance(pos1, pos2, shape) {
    if (!shape || shape.length === 0) {
      return this.haversineDistance(pos1.lat, pos1.lon, pos2.lat, pos2.lon);
    }
    
    const idx1 = this.findNearestPointOnShape(pos1.lat, pos1.lon, shape);
    const idx2 = this.findNearestPointOnShape(pos2.lat, pos2.lon, shape);
    
    // Ako je vozilo na istoj tački ili se vratilo, distanca je 0
    if (idx1 === idx2) {
      return 0;
    }
    
    let distance = 0;
    
    // Ako je idx2 < idx1, vozilo je možda završilo krug i počelo ponovo
    if (idx2 < idx1) {
      // Računamo od idx1 do kraja shape-a
      for (let i = idx1; i < shape.length - 1; i++) {
        distance += this.haversineDistance(
          shape[i].lat, shape[i].lon,
          shape[i + 1].lat, shape[i + 1].lon
        );
      }
      
      // Zatim od početka do idx2
      for (let i = 0; i < idx2; i++) {
        distance += this.haversineDistance(
          shape[i].lat, shape[i].lon,
          shape[i + 1].lat, shape[i + 1].lon
        );
      }
      
      return distance;
    }
    
    // Normalan slučaj - računamo distancu između SVE tačke na trasi od idx1 do idx2
    for (let i = idx1; i < idx2; i++) {
      distance += this.haversineDistance(
        shape[i].lat, shape[i].lon,
        shape[i + 1].lat, shape[i + 1].lon
      );
    }
    
    return distance;
  }

  getShapeForLine(lineNumber) {
    const mappingKey = Object.keys(this.routeMappingData).find(key => {
      const leftNumber = key.split(':')[0].trim();
      return leftNumber === lineNumber.toString();
    });
    
    if (!mappingKey) {
      return null;
    }
    
    const shapeId = this.routeMappingData[mappingKey];
    
    if (this.shapesData[shapeId]) return this.shapesData[shapeId];
    if (this.shapesGradskeData[shapeId]) return this.shapesGradskeData[shapeId];
    
    return null;
  }

  calculateVehicleSpeed(vehicleId, currentPosition, lineNumber) {
    const now = Date.now();
    
    if (!this.vehicleHistory[vehicleId]) {
      this.vehicleHistory[vehicleId] = {
        position: currentPosition,
        timestamp: now,
        lineNumber: lineNumber,
        speed: null
      };
      return null;
    }
    
    const prevData = this.vehicleHistory[vehicleId];
    const timeDiff = (now - prevData.timestamp) / 1000;
    
    // Ako je prošlo manje od 5 sekundi, sačekaj više podataka
    if (timeDiff < 5) {
      return prevData.speed;
    }
    
    // Ako je prošlo više od 5 minuta, resetuj (vozilo je stalo ili nova ruta)
    if (timeDiff > 300) {
      this.vehicleHistory[vehicleId] = {
        position: currentPosition,
        timestamp: now,
        lineNumber: lineNumber,
        speed: null
      };
      return null;
    }
    
    const shape = this.getShapeForLine(lineNumber);
    
    let distance;
    if (shape && shape.length > 0) {
      distance = this.calculateRouteDistance(prevData.position, currentPosition, shape);
    } else {
      // Fallback - direktna distanca ako nema shape podataka
      distance = this.haversineDistance(
        prevData.position.lat, prevData.position.lon,
        currentPosition.lat, currentPosition.lon
      );
    }
    
    // Ako je distanca 0 ili veća od 3km (prevelika za normalno kretanje), ignoriši
    if (distance === 0 || distance > 3000) {
      this.vehicleHistory[vehicleId] = {
        position: currentPosition,
        timestamp: now,
        lineNumber: lineNumber,
        speed: prevData.speed
      };
      return prevData.speed;
    }
    
    const speedMps = distance / timeDiff;
    const speedKmh = Math.round(speedMps * 3.6 * 10) / 10;
    
    // Dodatna validacija - ako je brzina preko 90 km/h, verovatno je greška
    const validSpeed = speedKmh <= 90 ? speedKmh : prevData.speed;
    
    this.vehicleHistory[vehicleId] = {
      position: currentPosition,
      timestamp: now,
      lineNumber: lineNumber,
      speed: validSpeed
    };
    
    return validSpeed;
  }

  // ========== ORIGINALNE FUNKCIJE ==========

  async loadStations() {
    const response = await fetch('/api/stations');
    this.stationsMap = await response.json();
    console.log('✅ Učitano stanica:', Object.keys(this.stationsMap).length);
  }

  async loadRouteNames() {
    const response = await fetch('/route-mapping.json');
    this.routeMappingData = await response.json();
    this.routeNamesMap = this.routeMappingData;
    console.log('✅ Učitano naziva linija:', Object.keys(this.routeNamesMap).length);
  }

  async loadVehicles() {
    document.getElementById('loadingCard').classList.remove('hidden');
    
    const response = await fetch('/api/vehicles');
    const data = await response.json();
    
    document.getElementById('loadingCard').classList.add('hidden');
    
    if (data && data.vehicles) {
      const vehicleDestinations = {};
      data.tripUpdates.forEach(update => {
        vehicleDestinations[update.vehicleId] = update.destination;
      });
      
      this.drawMarkers(data.vehicles, vehicleDestinations);
    }
  }

  drawMarkers(vehicles, vehicleDestinations) {
    this.markersLayer.clearLayers();
    this.allMarkers = {};
    
    vehicles.forEach(vehicle => {
      const routeNum = parseInt(vehicle.routeId);
      const routeDisplayName = this.getRouteDisplayName(vehicle.routeId);
      const destId = vehicleDestinations[vehicle.id] || "Unknown";
      const normalizedId = this.normalizeStopId(destId);
      const station = this.stationsMap[normalizedId];
      const destName = station ? station.name : destId;
      
      const uniqueDirKey = `${routeNum}_${destId}`;
      
      if (!this.directionColorMap[uniqueDirKey]) {
        const nextColorIndex = Object.keys(this.directionColorMap).length % this.colors.length;
        this.directionColorMap[uniqueDirKey] = this.colors[nextColorIndex];
      }
      
      const markerColor = this.directionColorMap[uniqueDirKey];

      // IZRAČUNAJ BRZINU
      const speed = this.calculateVehicleSpeed(
        vehicle.id,
        { lat: vehicle.lat, lon: vehicle.lon },
        routeNum
      );
      
      let rotation = 0;
      let hasAngle = false;

      if (station && station.coords) {
        rotation = this.calculateBearing(vehicle.lat, vehicle.lon, station.coords[0], station.coords[1]);
        hasAngle = true;
      }

      const arrowDisplay = hasAngle ? 'block' : 'none';

      const iconHtml = `
        <div class="bus-wrapper">
          <div class="bus-arrow" style="transform: rotate(${rotation}deg); display: ${arrowDisplay};">
            <div class="arrow-head" style="border-bottom-color: ${markerColor}; filter: brightness(0.6);"></div>
          </div>
          <div class="bus-circle" style="background: ${markerColor};">
            ${routeDisplayName}
          </div>
          <div class="bus-garage-label">${vehicle.label}</div>
        </div>
      `;

      const customIcon = L.divIcon({
        className: 'bus-icon-container',
        html: iconHtml,
        iconSize: [50, 56],
        iconAnchor: [25, 28]
      });

      const marker = L.marker([vehicle.lat, vehicle.lon], {icon: customIcon});

      // DODAJ BRZINU U POPUP
      let speedText = '';
      if (speed !== null && speed !== undefined && speed > 0) {
        speedText = `<div class="popup-row"><span class="popup-label">Prosečna brzina:</span> <b style="color: #2980b9;">${speed} km/h</b></div>`;
      } else {
        speedText = `<div class="popup-row"><span class="popup-label">Brzina:</span> <span style="color: #95a5a6;">Računanje...</span></div>`;
      }

      const popupContent = `
        <div class="popup-content">
          <div class="popup-row"><span class="popup-label">Linija:</span> <b>${routeDisplayName}</b></div>
          <div class="popup-row"><span class="popup-label">Vozilo:</span> ${vehicle.label}</div>
          <div class="popup-row"><span class="popup-label">Polazak:</span> ${vehicle.startTime}</div>
          <hr style="margin: 5px 0; border-color:#eee;">
          <div class="popup-row"><span class="popup-label">Smer (ide ka):</span> <span style="color:${markerColor}; font-weight:bold;">${destName}</span></div>
          ${speedText}
        </div>
      `;
      
      marker.bindPopup(popupContent);
      this.markersLayer.addLayer(marker);
      
      this.allMarkers[vehicle.label] = {
        marker: marker,
        lat: vehicle.lat,
        lon: vehicle.lon,
        routeNum: routeNum,
        routeDisplayName: routeDisplayName,
        vehicleLabel: vehicle.label,
        startTime: vehicle.startTime,
        destName: destName,
        vehicleId: vehicle.id,
        speed: speed
      };
    });
  }

  normalizeStopId(stopId) {
    if (typeof stopId === 'string' && stopId.length === 5 && stopId.startsWith('2')) {
      let normalized = stopId.substring(1);
      normalized = parseInt(normalized, 10).toString();
      return normalized;
    }
    return stopId;
  }

  normalizeRouteId(routeId) {
    if (typeof routeId === 'string') {
      return parseInt(routeId, 10).toString();
    }
    return routeId;
  }

  getRouteDisplayName(routeId) {
    const normalizedId = this.normalizeRouteId(routeId);
    return this.routeNamesMap[normalizedId] || normalizedId;
  }

  calculateBearing(startLat, startLng, destLat, destLng) {
    const y = Math.sin((destLng - startLng) * Math.PI / 180) * Math.cos(destLat * Math.PI / 180);
    const x = Math.cos(startLat * Math.PI / 180) * Math.sin(destLat * Math.PI / 180) -
              Math.sin(startLat * Math.PI / 180) * Math.cos(destLat * Math.PI / 180) * Math.cos((destLng - startLng) * Math.PI / 180);
    const brng = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    return brng;
  }

  startAutoRefresh() {
    setInterval(() => {
      this.loadVehicles();
    }, this.refreshInterval);
  }

  searchVehicles(query) {
    const resultsContainer = document.getElementById('searchResults');
    resultsContainer.innerHTML = '';
    
    if (!query || query.trim() === '') return;
    
    const searchTerm = query.toLowerCase().trim();
    const matchedVehicles = [];
    
    for (let vehicleLabel in this.allMarkers) {
      if (vehicleLabel.toLowerCase().includes(searchTerm)) {
        matchedVehicles.push(this.allMarkers[vehicleLabel]);
      }
    }
    
    const resultsToShow = matchedVehicles.slice(0, 2);
    
    resultsToShow.forEach(vehicle => {
      const resultItem = document.createElement('div');
      resultItem.className = 'search-result-item';
      
      let speedInfo = '';
      if (vehicle.speed !== null && vehicle.speed !== undefined && vehicle.speed > 0) {
        speedInfo = `<br><small>Brzina: ${vehicle.speed} km/h</small>`;
      }
      
      resultItem.innerHTML = '<strong>Vozilo:</strong> ' + vehicle.vehicleLabel + 
                            '<br><small>Linija: ' + vehicle.routeDisplayName + '</small>' +
                            speedInfo;
      
      resultItem.onclick = () => {
        this.map.setView([vehicle.lat, vehicle.lon], 16);
        vehicle.marker.openPopup();
        document.getElementById('searchInput').value = '';
        resultsContainer.innerHTML = '';
      };
      
      resultsContainer.appendChild(resultItem);
    });
  }
}


async function initApp() {
  const configResponse = await fetch('/api/config');
  const config = await configResponse.json();
  
  window.busApp = new BusMapApp(config);
  
  document.getElementById('searchInput').addEventListener('input', function(e) {
    window.busApp.searchVehicles(e.target.value);
  });
}
