class BusMapApp {
  constructor(config) {
    this.map = L.map('map').setView(config.mapCenter, config.mapZoom);
    this.markersLayer = L.layerGroup().addTo(this.map);
    this.routeLayers = {};
    this.colors = config.colors;
    this.directionColorMap = {};
    this.allMarkers = {};
    this.stationsMap = {};
    this.routeNamesMap = {};
    this.shapesData = {};
    this.vehicleShapeMap = {};
    this.refreshInterval = config.refreshInterval;
    this.activeRouteLayer = null;
    this.currentPopup = null;
    
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(this.map);
    
    // Dodaj event listener za klik na mapu
    this.map.on('click', (e) => {
      // Ako je klik na prazno mesto (ne na marker), obriši trasu
      if (e.originalEvent.target.tagName !== 'IMG' && 
          !e.originalEvent.target.closest('.leaflet-marker-icon') &&
          !e.originalEvent.target.closest('.leaflet-popup')) {
        this.clearActiveRoute();
      }
    });
    
    this.init();
  }

  async init() {
    await this.loadStations();
    await this.loadRouteNames();
    await this.loadShapes();
    this.loadVehicles();
    this.startAutoRefresh();
  }

  async loadStations() {
    const response = await fetch('/api/stations');
    this.stationsMap = await response.json();
  }

  async loadRouteNames() {
    const response = await fetch('/route-mapping.json');
    this.routeNamesMap = await response.json();
  }

  async loadShapes() {
    try {
      const [shapesResponse, shapesGradskeResponse] = await Promise.all([
        fetch('/api/shapes.txt'),
        fetch('/api/shapes_gradske.txt')
      ]);
      
      const shapesText = await shapesResponse.text();
      const shapesGradskeText = await shapesGradskeResponse.text();
      
      this.parseShapesCSV(shapesText);
      this.parseShapesCSV(shapesGradskeText);
      
      console.log('Shapes loaded:', Object.keys(this.shapesData).length);
    } catch (error) {
      console.error('Error loading shapes:', error);
    }
  }

  parseShapesCSV(csvText) {
    const lines = csvText.split('\n');
    
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      
      const parts = line.split(',');
      if (parts.length < 4) continue;
      
      const shapeId = parts[0];
      const lat = parseFloat(parts[1]);
      const lon = parseFloat(parts[2]);
      const sequence = parseInt(parts[3]);
      
      if (!this.shapesData[shapeId]) {
        this.shapesData[shapeId] = [];
      }
      
      this.shapesData[shapeId].push({
        lat: lat,
        lon: lon,
        sequence: sequence
      });
    }
    
    for (let shapeId in this.shapesData) {
      this.shapesData[shapeId].sort((a, b) => a.sequence - b.sequence);
    }
  }

  async loadVehicles() {
    document.getElementById('loadingCard').classList.remove('hidden');
    
    const response = await fetch('/api/vehicles');
    const data = await response.json();
    
    document.getElementById('loadingCard').classList.add('hidden');
    
    if (data && data.vehicles) {
      const vehicleDestinations = {};
      const vehicleShapes = {};
      
      console.log('=== API Response ===');
      console.log('Trip Updates:', data.tripUpdates);
      
      data.tripUpdates.forEach(update => {
        vehicleDestinations[update.vehicleId] = update.destination;
        console.log('Update za vozilo:', update.vehicleId, update);
        if (update.shapeId) {
          vehicleShapes[update.vehicleId] = update.shapeId;
        }
        if (update.shape_id) {
          vehicleShapes[update.vehicleId] = update.shape_id;
        }
      });
      
      this.vehicleShapeMap = vehicleShapes;
      this.vehicleDestinations = vehicleDestinations;
      
      console.log('Vehicle Shape Map:', vehicleShapes);
      console.log('Vehicle Destinations:', vehicleDestinations);
      console.log('Available shapes:', Object.keys(this.shapesData));
      
      this.drawMarkers(data.vehicles, vehicleDestinations);
    }
  }

  drawMarkers(vehicles, vehicleDestinations) {
    this.markersLayer.clearLayers();
    this.allMarkers = {};
    
    vehicles.forEach(vehicle => {
      const routeNum = parseInt(vehicle.routeId);
      const routeDisplayName = this.getRouteDisplayName(vehicle.routeId);
      const destId = vehicleDestinations[vehicle.id] || "Unknown";
      const normalizedId = this.normalizeStopId(destId);
      const station = this.stationsMap[normalizedId];
      const destName = station ? station.name : destId;
      
      const uniqueDirKey = `${routeNum}_${destId}`;
      
      if (!this.directionColorMap[uniqueDirKey]) {
        const nextColorIndex = Object.keys(this.directionColorMap).length % this.colors.length;
        this.directionColorMap[uniqueDirKey] = this.colors[nextColorIndex];
      }
      
      const markerColor = this.directionColorMap[uniqueDirKey];
      
      let rotation = 0;
      let hasAngle = false;

      if (station && station.coords) {
        rotation = this.calculateBearing(vehicle.lat, vehicle.lon, station.coords[0], station.coords[1]);
        hasAngle = true;
      }

      const arrowDisplay = hasAngle ? 'block' : 'none';

      const iconHtml = `
        <div class="bus-wrapper">
          <div class="bus-arrow" style="transform: rotate(${rotation}deg); display: ${arrowDisplay};">
            <div class="arrow-head" style="border-bottom-color: ${markerColor}; filter: brightness(0.6);"></div>
          </div>
          <div class="bus-circle" style="background: ${markerColor};">
            ${routeDisplayName}
          </div>
          <div class="bus-garage-label">${vehicle.label}</div>
        </div>
      `;

      const customIcon = L.divIcon({
        className: 'bus-icon-container',
        html: iconHtml,
        iconSize: [50, 56],
        iconAnchor: [25, 28]
      });

      const marker = L.marker([vehicle.lat, vehicle.lon], {icon: customIcon});

      const popupContent = `
        <div class="popup-content">
          <div class="popup-row"><span class="popup-label">Linija:</span> <b>${routeDisplayName}</b></div>
          <div class="popup-row"><span class="popup-label">Vozilo:</span> ${vehicle.label}</div>
          <div class="popup-row"><span class="popup-label">Polazak:</span> ${vehicle.startTime}</div>
          <hr style="margin: 5px 0; border-color:#eee;">
          <div class="popup-row"><span class="popup-label">Smer (ide ka):</span> <span style="color:${markerColor}; font-weight:bold;">${destName}</span></div>
        </div>
      `;
      
      const popup = L.popup().setContent(popupContent);
      marker.bindPopup(popup);
      
      // Kada se otvori popup, prikaži trasu
      marker.on('click', () => {
        this.currentPopup = popup;
        this.showRouteForVehicle(vehicle.routeId, vehicle.id, markerColor);
      });
      
      // Kada se zatvori popup, obriši trasu
      popup.on('remove', () => {
        this.clearActiveRoute();
        this.currentPopup = null;
      });
      
      this.markersLayer.addLayer(marker);
      
      this.allMarkers[vehicle.label] = {
        marker: marker,
        lat: vehicle.lat,
        lon: vehicle.lon,
        routeNum: routeNum,
        routeId: vehicle.routeId,
        routeDisplayName: routeDisplayName,
        vehicleLabel: vehicle.label,
        vehicleId: vehicle.id,
        startTime: vehicle.startTime,
        destName: destName,
        markerColor: markerColor
      };
    });
  }

  clearActiveRoute() {
    if (this.activeRouteLayer) {
      this.map.removeLayer(this.activeRouteLayer);
      this.activeRouteLayer = null;
    }
  }

  showRouteForVehicle(routeId, vehicleId, color) {
    this.clearActiveRoute();
    
    const shapeIdFromVehicle = this.vehicleShapeMap[vehicleId];
    const destination = this.vehicleDestinations[vehicleId];
    
    console.log('=== Prikazujem trasu ===');
    console.log('Vehicle ID:', vehicleId);
    console.log('Route ID:', routeId);
    console.log('Shape ID from API:', shapeIdFromVehicle);
    console.log('Destination:', destination);
    
    // Prvo pokušaj sa tačnim shape_id od vozila
    if (shapeIdFromVehicle) {
      console.log('Tražim tačan shape:', shapeIdFromVehicle);
      
      // Pokušaj direktno
      if (this.shapesData[shapeIdFromVehicle]) {
        console.log('✓ Našao tačan shape!');
        this.drawRoute(shapeIdFromVehicle, color);
        return;
      }
      
      // Pokušaj sa varijacijama (sa/bez padding nula)
      const variations = [
        shapeIdFromVehicle,
        shapeIdFromVehicle.replace(/^0+/, ''), // ukloni leading zeros
        shapeIdFromVehicle.padStart(shapeIdFromVehicle.length + 1, '0') // dodaj zero
      ];
      
      for (let variation of variations) {
        if (this.shapesData[variation]) {
          console.log('✓ Našao shape varijantu:', variation);
          this.drawRoute(variation, color);
          return;
        }
      }
      
      // Pokušaj fuzzy match - bilo koji shape koji sadrži isti pattern
      for (let shapeKey in this.shapesData) {
        if (shapeKey.includes(shapeIdFromVehicle) || shapeIdFromVehicle.includes(shapeKey)) {
          console.log('✓ Našao fuzzy match:', shapeKey);
          this.drawRoute(shapeKey, color);
          return;
        }
      }
    }
    
    // Ako nema shape_id, pokušaj da odrediš smer na osnovu destinacije
    console.log('Pokušavam da odredim smer na osnovu destinacije...');
    let matchingShapes = [];
    for (let shapeKey in this.shapesData) {
      if (shapeKey.startsWith(routeId + '_') || shapeKey.startsWith(routeId + '-')) {
        matchingShapes.push(shapeKey);
      }
    }
    
    console.log('Pronađeni shapes za rutu:', matchingShapes);
    
    if (matchingShapes.length > 0) {
      let selectedShape = matchingShapes[0]; // default
      
      // Ako imamo destinaciju, pokušaj da nađemo pravi smer
      if (destination && matchingShapes.length >= 2) {
        console.log('Imam više shapes, određujem pravi smer na osnovu destinacije:', destination);
        
        const normalizedDestination = this.normalizeStopId(destination);
        console.log('Normalizovana destinacija:', normalizedDestination);
        
        // Proveri koja stanica odgovara destinaciji
        const destStation = this.stationsMap[normalizedDestination];
        if (destStation && destStation.coords) {
          console.log('Pronađena destinaciona stanica:', destStation.name, destStation.coords);
          
          let bestMatch = null;
          let minDistance = Infinity;
          
          // Za svaki shape, proveri udaljenost krajnje tačke od destinacije
          matchingShapes.forEach(shapeKey => {
            const shapePoints = this.shapesData[shapeKey];
            if (shapePoints && shapePoints.length > 0) {
              // Uzmi poslednju tačku shape-a (krajnja stanica)
              const lastPoint = shapePoints[shapePoints.length - 1];
              
              // Izračunaj udaljenost od destinacije
              const distance = this.calculateDistance(
                lastPoint.lat, lastPoint.lon,
                destStation.coords[0], destStation.coords[1]
              );
              
              console.log(`Shape ${shapeKey}: krajnja tačka [${lastPoint.lat}, ${lastPoint.lon}], udaljenost: ${distance.toFixed(2)}m`);
              
              if (distance < minDistance) {
                minDistance = distance;
                bestMatch = shapeKey;
              }
            }
          });
          
          if (bestMatch) {
            selectedShape = bestMatch;
            console.log(`✓ Odabran shape ${selectedShape} na osnovu najbliže krajnje tačke (${minDistance.toFixed(2)}m)`);
          }
        } else {
          console.log('Destinaciona stanica nije pronađena u mapi stanica');
          
          // Fallback: pokušaj sa imenima smera (A/B)
          const shapeWithB = matchingShapes.find(s => s.includes('_B') || s.includes('direction_B'));
          const shapeWithA = matchingShapes.find(s => s.includes('_A') || s.includes('direction_A'));
          
          // Ako destinacija počinje sa većim brojem, verovatno je to smer B
          if (normalizedDestination > '10000') {
            selectedShape = shapeWithB || selectedShape;
            console.log('Odabran shape B na osnovu ID destinacije');
          } else {
            selectedShape = shapeWithA || selectedShape;
            console.log('Odabran shape A na osnovu ID destinacije');
          }
        }
      }
      
      this.drawRoute(selectedShape, color);
    } else {
      console.log('✗ Nije pronađen nijedan shape');
    }
  }

  drawRoute(shapeId, color) {
    const shapePoints = this.shapesData[shapeId];
    
    if (!shapePoints || shapePoints.length === 0) {
      console.log('Nema tačaka za shape:', shapeId);
      return;
    }
    
    const latLngs = shapePoints.map(point => [point.lat, point.lon]);
    
    const polyline = L.polyline(latLngs, {
      color: color,
      weight: 4,
      opacity: 0.7,
      smoothFactor: 1
    });
    
    polyline.addTo(this.map);
    this.activeRouteLayer = polyline;
    
    console.log('✓ Trasa iscrtana:', shapeId, 'sa', shapePoints.length, 'tačaka');
  }

  normalizeStopId(stopId) {
    if (typeof stopId === 'string' && stopId.length === 5 && stopId.startsWith('2')) {
      let normalized = stopId.substring(1);
      normalized = parseInt(normalized, 10).toString();
      return normalized;
    }
    return stopId;
  }

  normalizeRouteId(routeId) {
    if (typeof routeId === 'string') {
      return parseInt(routeId, 10).toString();
    }
    return routeId;
  }

  getRouteDisplayName(routeId) {
    const normalizedId = this.normalizeRouteId(routeId);
    return this.routeNamesMap[normalizedId] || normalizedId;
  }

  calculateBearing(startLat, startLng, destLat, destLng) {
    const y = Math.sin((destLng - startLng) * Math.PI / 180) * Math.cos(destLat * Math.PI / 180);
    const x = Math.cos(startLat * Math.PI / 180) * Math.sin(destLat * Math.PI / 180) -
              Math.sin(startLat * Math.PI / 180) * Math.cos(destLat * Math.PI / 180) * Math.cos((destLng - startLng) * Math.PI / 180);
    const brng = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    return brng;
  }

  // Nova funkcija za računanje udaljenosti između dve tačke (Haversine formula)
  calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3; // Radijus Zemlje u metrima
    const φ1 = lat1 * Math.PI / 180;
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c; // Vraća udaljenost u metrima
  }

  startAutoRefresh() {
    setInterval(() => {
      this.loadVehicles();
    }, this.refreshInterval);
  }

  searchVehicles(query) {
    const resultsContainer = document.getElementById('searchResults');
    resultsContainer.innerHTML = '';
    
    if (!query || query.trim() === '') return;
    
    const searchTerm = query.toLowerCase().trim();
    const matchedVehicles = [];
    
    for (let vehicleLabel in this.allMarkers) {
      if (vehicleLabel.toLowerCase().includes(searchTerm)) {
        matchedVehicles.push(this.allMarkers[vehicleLabel]);
      }
    }
    
    const resultsToShow = matchedVehicles.slice(0, 2);
    
    resultsToShow.forEach(vehicle => {
      const resultItem = document.createElement('div');
      resultItem.className = 'search-result-item';
      resultItem.innerHTML = '<strong>Vozilo:</strong> ' + vehicle.vehicleLabel + 
                            '<br><small>Linija: ' + vehicle.routeDisplayName + '</small>';
      
      resultItem.onclick = () => {
        this.map.setView([vehicle.lat, vehicle.lon], 16);
        vehicle.marker.openPopup();
        this.showRouteForVehicle(vehicle.routeId, vehicle.vehicleId, vehicle.markerColor);
        document.getElementById('searchInput').value = '';
        resultsContainer.innerHTML = '';
      };
      
      resultsContainer.appendChild(resultItem);
    });
  }
}


async function initApp() {
  const configResponse = await fetch('/api/config');
  const config = await configResponse.json();
  
  window.busApp = new BusMapApp(config);
  
  document.getElementById('searchInput').addEventListener('input', function(e) {
    window.busApp.searchVehicles(e.target.value);
  });
  
  let countdown = 65;
  setInterval(() => {
    countdown--;
    if (countdown <= 0) countdown = 65;
    document.getElementById('timer').textContent = countdown;
  }, 1000);
}
